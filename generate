#!/bin/bash

# generate - Universal README generator with guided setup
# Can be used locally or remotely via curl

set -e

VERSION="1.0.0"
TEMPLATE_URL="https://raw.githubusercontent.com/mitchellfyi/documentation/main/README-TEMPLATE.md"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Files
TEMPLATE_FILE="README-TEMPLATE.md"
CONTEXT_FILE="docs/context.yaml"
OUTPUT_FILE="README.md"

# Print colored output
print_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
print_success() { echo -e "${GREEN}✅ $1${NC}"; }
print_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
print_error() { echo -e "${RED}❌ $1${NC}"; }

# Show usage
show_usage() {
    cat << EOF
generate v$VERSION - Universal README generator

USAGE:
    ./generate [OPTIONS]

OPTIONS:
    -h, --help        Show this help
    -v, --version     Show version
    --remote          Use remote template (downloads from GitHub)
    --force           Overwrite existing files without asking
    --skip-quality    Skip quality checks after generation

EXAMPLES:
    # Local usage (in this repo)
    ./generate

    # Remote usage (in any project)
    curl -sSL https://raw.githubusercontent.com/mitchellfyi/documentation/main/generate | bash

    # With remote template
    ./generate --remote
    
    # Skip quality checks (faster generation)
    ./generate --skip-quality

SETUP:
    If no docs/context.yaml exists, the script will guide you through
    creating one with interactive questions.

EOF
}

# Function to extract value from YAML file
get_yaml_value() {
    local key="$1"
    local file="$2"
    grep "^${key}:" "$file" 2>/dev/null | sed "s/^${key}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//' || echo ""
}

# Function to ask user questions and create context.yaml
create_context_file() {
    print_info "Creating docs/context.yaml with guided questions..."
    echo

    # Create docs directory if it doesn't exist
    mkdir -p docs

    # Collect information
    echo -n "Project name: "
    read -r project_name
    
    echo -n "Domain (e.g., web app, CLI tool, data platform): "
    read -r domain
    
    echo -n "Primary audience (e.g., developers, data engineers, SREs): "
    read -r audience
    
    echo -n "Interfaces (e.g., CLI, REST API, SDK): "
    read -r interfaces
    
    echo -n "Runtime requirements (e.g., Python 3.11+, Node 20+, language-agnostic): "
    read -r runtime
    
    echo -n "Storage backends (e.g., Postgres, S3, filesystem): "
    read -r storage
    
    echo -n "Deployment targets (e.g., Docker, K8s, GitHub): "
    read -r deployment
    
    echo -n "Status (experimental, beta, stable, maintenance, archived): "
    read -r status
    
    echo -n "License (e.g., MIT, Apache-2.0): "
    read -r license
    
    echo -n "Support channel (e.g., GitHub Issues, email): "
    read -r support

    # Write context.yaml
    cat > "$CONTEXT_FILE" << EOF
project: $project_name
domain: $domain
audience: $audience
interfaces: $interfaces
runtime: $runtime
storage: $storage
deployment: $deployment
status: $status
license: $license
support: $support
EOF

    print_success "Created $CONTEXT_FILE"
}

# Function to create docs scaffold with minimal content
create_docs_scaffold() {
    print_info "Creating docs scaffold..."
    
    # Create docs directory if it doesn't exist
    mkdir -p docs
    
    # Define the files to create with their basic headings
    declare -A docs_files=(
        ["docs/QUICKSTART.md"]="# Quickstart"
        ["docs/USAGE.md"]="# Usage"
        ["docs/INSTALL.md"]="# Installation"
        ["docs/CONFIGURATION.md"]="# Configuration"
        ["docs/ARCHITECTURE.md"]="# Architecture"
        ["docs/ROADMAP.md"]="# Roadmap"
        ["docs/CONTRIBUTING.md"]="# Contributing"
        ["docs/CODE_OF_CONDUCT.md"]="# Code of Conduct"
        ["docs/SECURITY.md"]="# Security"
    )
    
    local created_files=()
    local skipped_files=()
    
    # Create each file if it doesn't exist or is empty
    for file in "${!docs_files[@]}"; do
        if [[ -f "$file" && -s "$file" ]]; then
            # File exists and is non-empty, skip it
            skipped_files+=("$file")
            print_warning "Skipped $file (non-empty file exists)"
        else
            # File doesn't exist or is empty, create it
            echo "${docs_files[$file]}" > "$file"
            created_files+=("$file")
            print_success "Created $file"
        fi
    done
    
    # Create context.yaml if it doesn't exist
    if [[ ! -f "$CONTEXT_FILE" ]]; then
        # This shouldn't happen in normal flow, but handle edge case
        print_warning "$CONTEXT_FILE missing, creating placeholder"
        cat > "$CONTEXT_FILE" << EOF
project: [Your Project Name]
domain: [project domain]
audience: [target audience]
interfaces: [interfaces]
runtime: [runtime requirements]
storage: [storage backends]
deployment: [deployment targets]
status: [project status]
license: [license]
support: [support channel]
EOF
        created_files+=("$CONTEXT_FILE")
        print_success "Created $CONTEXT_FILE"
    fi
    
    echo
    if [[ ${#created_files[@]} -gt 0 ]]; then
        print_success "Docs scaffold created! Files added:"
        printf '  %s\n' "${created_files[@]}"
    fi
    
    if [[ ${#skipped_files[@]} -gt 0 ]]; then
        echo
        print_info "Existing files preserved:"
        printf '  %s\n' "${skipped_files[@]}"
    fi
}

# Clean up template-specific content
clean_template_content() {
    print_info "Cleaning up template-specific content..."
    
    # Remove HTML comments (including multiline ones)
    sed -i.bak '/<!--/,/-->/d' "$OUTPUT_FILE"
    
    # Remove instructional text and template guidance
    sed -i.bak '/> If you cannot host a live demo/d' "$OUTPUT_FILE"
    sed -i.bak '/Keep it demo-first, skimmable/d' "$OUTPUT_FILE"
    sed -i.bak '/Remove any section marked optional/d' "$OUTPUT_FILE"
    
    # Remove optional section markers from headers and table of contents
    sed -i.bak 's/ (optional)//g' "$OUTPUT_FILE"
    sed -i.bak 's/#configuration-optional/#configuration/g' "$OUTPUT_FILE"
    sed -i.bak 's/#architecture-optional/#architecture/g' "$OUTPUT_FILE"
    
    # Fix the context section - replace the entire section properly
    sed -i.bak '/## Context for humans and AI/,/^---$/c\
## Context for humans and AI\
```yaml\
project: '"$PROJECT_NAME_SHELL"'\
domain: '"$DOMAIN_SHELL"'\
audience: '"$AUDIENCE_SHELL"'\
interfaces: '"$INTERFACES_SHELL"'\
runtime: '"$RUNTIME_SHELL"'\
storage: '"$STORAGE_SHELL"'\
deployment: '"$DEPLOYMENT_SHELL"'\
status: '"$STATUS_SHELL"'\
license: '"$LICENSE_SHELL"'\
support: '"$SUPPORT_SHELL"'\
```\
\
---' "$OUTPUT_FILE"
    
    # Remove sections that are commonly not needed or empty
    sed -i.bak '/## Deploy$/,/^## /{ /## Deploy$/d; /^## /!d; }' "$OUTPUT_FILE"
    sed -i.bak '/## Maintainers$/,/^```$/d' "$OUTPUT_FILE"
    
    # Remove placeholder table rows that weren't filled
    sed -i.bak '/{{OPTION_[0-9]}}/d' "$OUTPUT_FILE"
    sed -i.bak '/{{DEFAULT_[0-9]}}/d' "$OUTPUT_FILE"
    sed -i.bak '/{{FEATURE_ROW_[0-9]}}/d' "$OUTPUT_FILE"
    
    # Remove empty comparison table if not filled
    sed -i.bak '/| Feature.*{{PROJECT_NAME}}/,+3d' "$OUTPUT_FILE"
    
    # Remove empty or placeholder architecture diagram
    sed -i.bak '/!\[{{ARCH_DIAGRAM_ALT}}\]/d' "$OUTPUT_FILE"
    
    # Remove empty table headers that might be left
    sed -i.bak '/^| Option.*| Default.*| Description/d' "$OUTPUT_FILE"
    sed -i.bak '/^| -.*| -.*| -/d' "$OUTPUT_FILE"
    
    # Clean up multiple consecutive empty lines (reduce to single empty line)
    awk 'BEGIN{blank=0} /^$/{blank++; if(blank<=1) print} !/^$/{blank=0; print}' "$OUTPUT_FILE" > "$OUTPUT_FILE.tmp" && mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"
    
    # Remove trailing whitespace
    sed -i.bak 's/[[:space:]]*$//' "$OUTPUT_FILE"
    
    # Clean up backup file from this function
    rm -f "$OUTPUT_FILE.bak"
}

# Download template if using remote mode
download_template() {
    print_info "Downloading template from GitHub..."
    if command -v curl >/dev/null 2>&1; then
        curl -sSL "$TEMPLATE_URL" -o "$TEMPLATE_FILE"
    elif command -v wget >/dev/null 2>&1; then
        wget -q "$TEMPLATE_URL" -O "$TEMPLATE_FILE"
    else
        print_error "Neither curl nor wget found. Cannot download template."
        exit 1
    fi
    print_success "Downloaded $TEMPLATE_FILE"
}

# Run quality checks on generated documentation
run_quality_checks() {
    print_info "Running quality checks on generated README.md..."
    
    # Check if scripts directory exists
    if [[ ! -d "scripts" ]]; then
        print_warning "Scripts directory not found. Skipping quality checks."
        print_info "Run 'git clone https://github.com/mitchellfyi/documentation.git' or add scripts manually."
        return 0
    fi
    
    local quality_passed=true
    
    echo
    print_info "1️⃣  Formatting check..."
    if [[ -x "scripts/format.sh" ]]; then
        if timeout 30s npx prettier "$OUTPUT_FILE" --check --log-level warn 2>/dev/null; then
            print_success "Formatting is correct"
        else
            print_warning "Formatting issues found. Auto-fixing..."
            if timeout 30s npx prettier "$OUTPUT_FILE" --write --log-level warn 2>/dev/null; then
                print_success "Formatting applied"
            else
                print_warning "Could not auto-fix formatting"
                quality_passed=false
            fi
        fi
    else
        print_warning "Format script not found, skipping"
    fi
    
    echo
    print_info "2️⃣  Markdown linting..."
    if [[ -x "scripts/lint-markdown.sh" ]]; then
        if timeout 30s npx markdownlint-cli2 "$OUTPUT_FILE" 2>/dev/null; then
            print_success "Markdown linting passed"
        else
            print_warning "Markdown linting issues found"
            quality_passed=false
        fi
    else
        print_warning "Markdown lint script not found, skipping"
    fi
    
    echo
    print_info "3️⃣  Spell checking..."
    if [[ -x "scripts/spell-check.sh" ]]; then
        if timeout 60s npx cspell "$OUTPUT_FILE" --no-must-find-files --locale en-GB 2>/dev/null; then
            print_success "Spell checking passed"
        else
            print_warning "Spelling issues found"
            quality_passed=false
        fi
    else
        print_warning "Spell check script not found, skipping"
    fi
    
    echo
    print_info "4️⃣  Link checking..."
    if [[ -x "scripts/link-check.sh" ]]; then
        if timeout 30s npx markdown-link-check -q "$OUTPUT_FILE" 2>/dev/null; then
            print_success "Link checking passed"
        else
            print_warning "Link issues found (may be expected for new projects)"
        fi
    else
        print_warning "Link check script not found, skipping"
    fi
    
    echo
    if [[ "$quality_passed" == true ]]; then
        print_success "✨ All quality checks passed!"
    else
        print_warning "Some quality issues found. Run 'scripts/check-quality.sh' for details."
        print_info "Quality issues are common in generated READMEs and can be fixed manually."
    fi
}

# Main generation function
generate_readme() {
    local use_remote=false
    local force=false
    local skip_quality=false
    local docs_scaffold_created=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                echo "generate v$VERSION"
                exit 0
                ;;
            --remote)
                use_remote=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --skip-quality)
                skip_quality=true
                shift
                ;;
            --auto-run)
                # Internal flag - just ignore it as it's already handled in main()
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    print_info "Starting README generation..."

    # Check for template file
    if [[ "$use_remote" == true ]] || [[ ! -f "$TEMPLATE_FILE" ]]; then
        download_template
    fi

    if [[ ! -f "$TEMPLATE_FILE" ]]; then
        print_error "$TEMPLATE_FILE not found"
        print_info "Run with --remote to download template, or ensure template exists locally"
        exit 1
    fi

    # Check for context file
    if [[ ! -f "$CONTEXT_FILE" ]]; then
        print_warning "$CONTEXT_FILE not found"
        echo
        create_context_file
        echo
    fi

    # Check if README.md exists and ask before overwriting
    if [[ -f "$OUTPUT_FILE" && "$force" != true ]]; then
        echo -n "README.md already exists. Overwrite? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            print_info "Aborted. Use --force to overwrite without asking."
            exit 0
        fi
    fi

    # Extract values from context.yaml
    PROJECT_NAME=$(get_yaml_value "project" "$CONTEXT_FILE")
    DOMAIN=$(get_yaml_value "domain" "$CONTEXT_FILE")
    AUDIENCE=$(get_yaml_value "audience" "$CONTEXT_FILE")
    INTERFACES=$(get_yaml_value "interfaces" "$CONTEXT_FILE")
    RUNTIME=$(get_yaml_value "runtime" "$CONTEXT_FILE")
    STORAGE=$(get_yaml_value "storage" "$CONTEXT_FILE")
    DEPLOYMENT=$(get_yaml_value "deployment" "$CONTEXT_FILE")
    STATUS=$(get_yaml_value "status" "$CONTEXT_FILE")
    LICENSE=$(get_yaml_value "license" "$CONTEXT_FILE")
    SUPPORT=$(get_yaml_value "support" "$CONTEXT_FILE")

    print_info "Generating README.md for: $PROJECT_NAME"

    # Start with the template
    cp "$TEMPLATE_FILE" "$OUTPUT_FILE"

    # Escape special characters for sed (comprehensive escaping for all metacharacters)
    escape_for_sed() {
        local input="$1"
        # Escape backslashes first, then other metacharacters
        # Using | as delimiter, so we need to escape |, \, &, and other problematic chars
        echo "$input" | sed 's/\\/\\\\/g; s/|/\\|/g; s/&/\\&/g; s/\[/\\[/g; s/\]/\\]/g; s/\./\\./g; s/\*/\\*/g; s/\^/\\^/g; s/\$/\\$/g; s/(/\\(/g; s/)/\\)/g; s/+/\\+/g; s/?/\\?/g; s/{/\\{/g'
    }

    # Escape special characters for shell variable interpolation
    escape_for_shell() {
        local input="$1"
        # Escape backslashes and single quotes for shell variable interpolation
        echo "$input" | sed 's/\\/\\\\/g; s/'"'"'/'"'"'\\\'"'"'/g'
    }

    # Apply escaping to all variables that will be used in sed replacements
    PROJECT_NAME_ESC=$(escape_for_sed "$PROJECT_NAME")
    DOMAIN_ESC=$(escape_for_sed "$DOMAIN")
    AUDIENCE_ESC=$(escape_for_sed "$AUDIENCE")
    INTERFACES_ESC=$(escape_for_sed "$INTERFACES")
    RUNTIME_ESC=$(escape_for_sed "$RUNTIME")
    STORAGE_ESC=$(escape_for_sed "$STORAGE")
    DEPLOYMENT_ESC=$(escape_for_sed "$DEPLOYMENT")
    STATUS_ESC=$(escape_for_sed "$STATUS")
    LICENSE_ESC=$(escape_for_sed "$LICENSE")
    SUPPORT_ESC=$(escape_for_sed "$SUPPORT")

    # Apply shell escaping for variables used in shell interpolation (context section)
    PROJECT_NAME_SHELL=$(escape_for_shell "$PROJECT_NAME")
    DOMAIN_SHELL=$(escape_for_shell "$DOMAIN")
    AUDIENCE_SHELL=$(escape_for_shell "$AUDIENCE")
    INTERFACES_SHELL=$(escape_for_shell "$INTERFACES")
    RUNTIME_SHELL=$(escape_for_shell "$RUNTIME")
    STORAGE_SHELL=$(escape_for_shell "$STORAGE")
    DEPLOYMENT_SHELL=$(escape_for_shell "$DEPLOYMENT")
    STATUS_SHELL=$(escape_for_shell "$STATUS")
    LICENSE_SHELL=$(escape_for_shell "$LICENSE")
    SUPPORT_SHELL=$(escape_for_shell "$SUPPORT")

    # Replace placeholders with actual values (using | delimiter to avoid conflicts with / in values)
    sed -i.bak "s|{{PROJECT_NAME}}|$PROJECT_NAME_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DOMAIN}}|$DOMAIN_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{PRIMARY_AUDIENCE}}|$AUDIENCE_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{AUDIENCE}}|$AUDIENCE_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{INTERFACES}}|$INTERFACES_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{RUNTIME_REQS}}|$RUNTIME_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{STORAGE_BACKENDS}}|$STORAGE_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DEPLOY_TARGETS}}|$DEPLOYMENT_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{STATUS}}|$STATUS_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{LICENSE_SHORT}}|$LICENSE_ESC|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{PRIMARY_SUPPORT_CHANNEL}}|$SUPPORT_ESC|g" "$OUTPUT_FILE"

    # Generic replacements for common placeholders (using | delimiter for consistency)
    sed -i.bak "s|{{PROJECT_TAGLINE}}|[Add your one-line project description]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DEMO_URL}}|[Add demo URL or remove this section]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DEMO_GIF_ALT}}|Demo screenshot|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DEMO_GIF_FILENAME}}|demo.gif|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DEMO_CAPTION}}|[Add demo caption]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{CATEGORY}}|[project category]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{PRIMARY_OUTCOME}}|[main benefit or outcome]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{ALT_1}}|[alternative 1]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{ALT_2}}|[alternative 2]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{KEY_DIFFERENTIATOR}}|[key advantage]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{INSTALL_CMD}}|[installation command]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{DEMO_CMD}}|[demo command]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{USAGE_EXAMPLE_CMD}}|[usage example]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{EXPECTED_OUTPUT_SNIPPET}}|[expected output]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_1}}|[Feature 1]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_1_BENEFIT}}|[benefit description]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_2}}|[Feature 2]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_2_BENEFIT}}|[benefit description]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_3}}|[Feature 3]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_3_BENEFIT}}|[benefit description]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_4}}|[Feature 4]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_4_BENEFIT}}|[benefit description]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_5}}|[Feature 5]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{FEATURE_5_BENEFIT}}|[benefit description]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{SUPPORTED_OS}}|[supported operating systems]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{RUNTIME_VERSIONS}}|[runtime versions]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{CPU_GPU_REQUIREMENTS}}|[hardware requirements]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{EXTERNAL_DEPENDENCIES}}|[external dependencies]|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{LICENSE_LONG}}|$LICENSE_ESC License|g" "$OUTPUT_FILE"
    sed -i.bak "s|{{SECURITY_CONTACT}}|[security contact email]|g" "$OUTPUT_FILE"

    # Clean up template-specific content
    clean_template_content

    # Clean up backup file
    rm -f "$OUTPUT_FILE.bak"

    print_success "README.md generated successfully!"
    
    # Ask user if they want to create docs scaffold
    echo
    echo -n "Create docs scaffold now? [Y/n]: "
    read -r create_docs_response
    if [[ "$create_docs_response" =~ ^[Nn]$ ]]; then
        print_info "Skipped docs scaffold creation"
        docs_scaffold_created=false
    else
        echo
        create_docs_scaffold
        docs_scaffold_created=true
    fi
    
    # Run quality checks on the generated README (unless skipped)
    if [[ "$skip_quality" != true ]]; then
        echo
        run_quality_checks
    else
        print_info "Quality checks skipped (--skip-quality flag used)"
    fi
    
    echo
    print_info "Next steps:"
    echo "  📝 Review and customize the generated README.md"
    echo "  🔍 Search for remaining [placeholders] and replace them"
    echo "  🧹 Run 'scripts/check-quality.sh' for comprehensive quality checks"
    if [[ "$docs_scaffold_created" == true ]]; then
        echo "  📁 Customize your docs structure:"
        echo "     📖 docs/QUICKSTART.md - Quick start guide for new users"
        echo "     📚 docs/USAGE.md - Detailed usage instructions"
        echo "     ⚙️  docs/INSTALL.md - Installation instructions"
        echo "     🔧 docs/CONFIGURATION.md - Configuration options"
        echo "     🏗️  docs/ARCHITECTURE.md - System architecture"
        echo "     🛣️  docs/ROADMAP.md - Project roadmap"
        echo "     🤝 docs/CONTRIBUTING.md - Contribution guidelines"
        echo "     📋 docs/CODE_OF_CONDUCT.md - Code of conduct"
        echo "     🔒 docs/SECURITY.md - Security policy"
    else
        echo "  📁 Create docs/ structure if needed:"
        echo "     Re-run ./generate to create docs scaffold, or manually:"
        echo "     mkdir -p docs && touch docs/{QUICKSTART,USAGE,INSTALL,CONFIGURATION,ARCHITECTURE,ROADMAP,CONTRIBUTING,CODE_OF_CONDUCT,SECURITY}.md"
    fi
    echo "  📄 Add LICENSE file if needed"
    
    # Show remaining placeholders
    remaining=$(grep -o '\[.*\]' "$OUTPUT_FILE" 2>/dev/null | sort -u || true)
    if [[ -n "$remaining" ]]; then
        echo
        print_warning "Remaining placeholders to customize:"
        echo "$remaining" | sed 's/^/    /'
    fi
}

# Remote installation function
install_remote() {
    print_info "Installing generate script..."
    
    # Download script to current directory
    if command -v curl >/dev/null 2>&1; then
        curl -sSL "https://raw.githubusercontent.com/mitchellfyi/documentation/main/generate" -o generate
    elif command -v wget >/dev/null 2>&1; then
        wget -q "https://raw.githubusercontent.com/mitchellfyi/documentation/main/generate" -O generate
    else
        print_error "Neither curl nor wget found. Cannot download script."
        exit 1
    fi
    
    chmod +x generate
    print_success "Script installed as ./generate"
    
    # Check if we're in an interactive session (TTY)
    if [[ -t 1 ]]; then
        # Interactive session - auto-run the generator
        print_info "Detected interactive session. Running generator now..."
        echo
        # Pass a special flag to indicate this is an auto-run
        exec ./generate --auto-run "$@"
    else
        # Non-interactive (CI) session - just download and show next steps
        print_info "Downloaded in non-interactive session."
        print_info "Next step: Run './generate' to create your README"
    fi
}

# Main execution
main() {
    # Check for auto-run flag (indicates this is being run after installation)
    if [[ "$1" == "--auto-run" ]]; then
        # Remove the auto-run flag and run generator directly
        shift
        generate_readme "$@"
    elif [[ -t 0 ]]; then
        # Running normally (stdin is a terminal)
        generate_readme "$@"
    else
        # Being piped from curl (stdin is not a terminal)
        install_remote "$@"
    fi
}

# Run main function with all arguments
main "$@"
